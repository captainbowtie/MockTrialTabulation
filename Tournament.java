/*
 * Copyright (C) 2016 captainbowtie
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package com.allenbarr.MockTrialTabulation;

import java.io.File;
import java.io.Serializable;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;

/**
 *
 * @author captainbowtie
 */
public class Tournament implements Serializable {

    private static final long serialVersionUID = 20160904;

    private final boolean lowerTeamNumberIsHigherRank;
    private final boolean round3Rank1IsPlaintiff;
    private final ArrayList<Team> teams;
    private final Random random = new Random();

    /**
     * Default constructor. Creates a Tournament and initializes the team list
     *
     */
    public Tournament() {
        teams = new ArrayList<>();
        lowerTeamNumberIsHigherRank = random.nextBoolean();
        round3Rank1IsPlaintiff = random.nextBoolean();
    }

    /**
     * Constructor for when a tournament is being restored from a save state.
     * The save state should be either one generated by this class or one
     * following the format of this class, otherwise the restore will not
     * succeed
     *
     * @param csvFile file object where the save state is stored.
     */
    public Tournament(boolean lowerTeamNumberIsHigherRank, boolean round3Rank1IsPlaintiff) {
        teams = new ArrayList<>();
        this.lowerTeamNumberIsHigherRank = lowerTeamNumberIsHigherRank;
        this.round3Rank1IsPlaintiff = round3Rank1IsPlaintiff;
    }

    /**
     * Adds a new team with the specified number, name, and impermissible
     * matches to that list
     *
     * @param teamNumber team number of the team to be added
     * @param teamName team name of the team to be added
     * @param impermissibleMatches list of teams (by team number) the team to be
     * added cannot face
     */
    public void addTeam(int teamNumber, String teamName, List impermissibleMatches, boolean isByeTeam) {
        teams.add(new Team(teamNumber, teamName, impermissibleMatches, isByeTeam));
    }

    /**
     * Adds a team object, created by an external class, to the team list
     *
     * @param team Team object to be added to the list of teams
     */
    public void addTeam(Team team) {
        this.teams.add(team);
    }

    /**
     * Writes the tournament, in CSV format, to the specified file location
     *
     * @param saveLocation the location in the file system to save the
     * tournament to
     */
    public void writeToCSV(File saveLocation) {
        SpreadsheetHandler.saveToSpreadsheet(this, saveLocation);
    }

    /**
     * Returns the List of teams competing at the tournament
     *
     * @return teams competing at the tournament in List form
     */
    public ArrayList<Team> getTeams() {
        return teams;
    }

    /**
     * Returns the Team at the specified index from the List of teams
     *
     * @param index
     * @return Team at the specified index from the Team List
     */
    public Team getTeam(int index) {
        return teams.get(index);
    }

    /**
     * Pairs the teams randomly for round 1, resolving any impermissible
     * matches, then returns the proposed pairings so they can be confirmed
     * before writing them to the teams
     *
     * @return Array of size [teams/2][2], with the plaintiff for each pairing,
     * p, in [p][0] and defense in [p][1]
     */
    public int[][] pairRound1() {
        ArrayList<Team> pairings = new ArrayList<>();
        ArrayList<Team> teamArray = (ArrayList<Team>) teams.clone();
        for (int a = 0; a < teams.size(); a++) {
            int index = random.nextInt(teamArray.size());
            pairings.add(teamArray.get(index));
            teamArray.remove(index);
        }
        pairings = resolveImpermissibleMatches(pairings);
        int[][] pairingsReturn = new int[teams.size() / 2][2];
        for (int a = 0; a < teams.size() / 2; a++) {
            pairingsReturn[a][0] = pairings.get(a * 2).getTeamNumber();
            pairingsReturn[a][1] = pairings.get(a * 2 + 1).getTeamNumber();
        }
        return pairingsReturn;
    }

    public int[][] pairRound2() {
        final ArrayList<Team> plaintiffs;
        final ArrayList<Team> defendants;
        final ArrayList<Team> needsPlaintiff = new ArrayList<>();
        final ArrayList<Team> needsDefense = new ArrayList<>();

        for (int a = 0; a < teams.size(); a++) {
            if (teams.get(a).isRound1Plaintiff()) {
                needsDefense.add(teams.get(a));
            } else {
                needsPlaintiff.add(teams.get(a));
            }
        }
        plaintiffs = sortTeams(needsPlaintiff);
        defendants = sortTeams(needsDefense);
        ArrayList<Team>[] pairings = resolveImpermissibleMatches(plaintiffs, defendants);
        int[][] pairingsReturn = new int[teams.size() / 2][2];
        for (int a = 0; a < pairings[0].size(); a++) {
            pairingsReturn[a][0] = pairings[0].get(a).getTeamNumber();
            pairingsReturn[a][1] = pairings[1].get(a).getTeamNumber();
        }
        return pairingsReturn;
    }

    public int[][] pairRound3() {
        ArrayList<Team> pairings = sortTeams((ArrayList<Team>) teams.clone());
        pairings = resolveImpermissibleMatches(pairings);
        int[][] pairingsReturn = new int[teams.size() / 2][2];
        for (int a = 0; a < teams.size() / 2; a = a + 2) {
            if (round3Rank1IsPlaintiff) {
                pairingsReturn[a][0] = pairings.get(a * 2).getTeamNumber();
                pairingsReturn[a][1] = pairings.get(a * 2 + 1).getTeamNumber();
                if (a + 1 < teams.size() / 2) {
                    pairingsReturn[a + 1][0] = pairings.get(a * 2 + 3).getTeamNumber();
                    pairingsReturn[a + 1][1] = pairings.get(a * 2 + 2).getTeamNumber();
                }
            } else {
                pairingsReturn[a][0] = pairings.get(a * 2 + 1).getTeamNumber();
                pairingsReturn[a][1] = pairings.get(a * 2).getTeamNumber();
                if (a + 1 < teams.size() / 2) {
                    pairingsReturn[a + 1][0] = pairings.get(a * 2 + 2).getTeamNumber();
                    pairingsReturn[a + 1][1] = pairings.get(a * 2 + 3).getTeamNumber();
                }
            }

        }
        return pairingsReturn;
    }

    public int[][] pairRound4() {
        ArrayList<Team> plaintiffs;
        ArrayList<Team> defendants;
        ArrayList<Team> needsPlaintiff = new ArrayList<>();
        ArrayList<Team> needsDefense = new ArrayList<>();

        for (int a = 0; a < teams.size(); a++) {
            if (teams.get(a).isRound3Plaintiff()) {
                needsDefense.add(teams.get(a));
            } else {
                needsPlaintiff.add(teams.get(a));
            }
        }
        plaintiffs = sortTeams(needsPlaintiff);
        defendants = sortTeams(needsDefense);
        ArrayList<Team>[] pairings = resolveImpermissibleMatches(plaintiffs, defendants);
        int[][] pairingsReturn = new int[teams.size() / 2][2];
        for (int a = 0; a < pairings[0].size(); a++) {
            pairingsReturn[a][0] = pairings[0].get(a).getTeamNumber();
            pairingsReturn[a][1] = pairings[1].get(a).getTeamNumber();
        }
        return pairingsReturn;
    }

    private ArrayList<Team>[] resolveImpermissibleMatches(ArrayList<Team> plaintiffs, ArrayList<Team> defendants) {
        final ArrayList<Integer[]> swapList = new ArrayList<>();
        for (int a = 0; a < plaintiffs.size(); a++) {
            System.out.println(a);
            if (plaintiffs.get(a).getImpermissibleMatches().contains(defendants.get(a).getTeamNumber())) {
                int plaintiffRankDistance = Integer.MAX_VALUE;
                int defenseRankDistance = Integer.MAX_VALUE;
                for (int b = 0; b < plaintiffs.size(); b++) {
                    Integer[] proposedPlaintiffSwap = {Math.min(plaintiffs.get(a).getTeamNumber(), plaintiffs.get(b).getTeamNumber()), Math.max(plaintiffs.get(a).getTeamNumber(), plaintiffs.get(b).getTeamNumber())};
                    Integer[] proposedDefenseSwap = {Math.min(defendants.get(a).getTeamNumber(), defendants.get(b).getTeamNumber()), Math.max(defendants.get(a).getTeamNumber(), defendants.get(b).getTeamNumber())};
                    if (a - b != 0 && !swapList.contains(proposedPlaintiffSwap)) {
                        if (Math.abs(a - b) < plaintiffRankDistance) {
                            plaintiffRankDistance = Math.abs(a - b);
                        }
                    }
                    if (a - b != 0 && !swapList.contains(proposedDefenseSwap)) {
                        if (Math.abs(a - b) < defenseRankDistance) {
                            defenseRankDistance = Math.abs(a - b);
                        }
                    }
                }
                ArrayList<Team> proposedPlaintiffSwapTeams = new ArrayList<>();
                ArrayList<Team> proposedDefenseSwapTeams = new ArrayList<>();
                for (int b = 0; b < plaintiffs.size(); b++) {
                    Integer[] proposedPlaintiffSwap = {Math.min(plaintiffs.get(a).getTeamNumber(), plaintiffs.get(b).getTeamNumber()), Math.max(plaintiffs.get(a).getTeamNumber(), plaintiffs.get(b).getTeamNumber())};
                    Integer[] proposedDefenseSwap = {Math.min(defendants.get(a).getTeamNumber(), defendants.get(b).getTeamNumber()), Math.max(defendants.get(a).getTeamNumber(), defendants.get(b).getTeamNumber())};
                    boolean plaintiffClearsSwapList = true;
                    for (int c = 0; c < swapList.size(); c++) {
                        if (swapList.get(c)[0].equals(proposedPlaintiffSwap[0]) && swapList.get(c)[1].equals(proposedPlaintiffSwap[1])) {
                            plaintiffClearsSwapList = false;
                        }
                    }
                    boolean defendantClearsSwapList = true;
                    for (int c = 0; c < swapList.size(); c++) {
                        if (swapList.get(c)[0].equals(proposedDefenseSwap[0]) && swapList.get(c)[1].equals(proposedDefenseSwap[1])) {
                            defendantClearsSwapList = false;
                        }
                    }
                    if (Math.abs(a - b) == plaintiffRankDistance && plaintiffClearsSwapList) {
                        proposedPlaintiffSwapTeams.add(plaintiffs.get(b));
                    }
                    if (Math.abs(a - b) == defenseRankDistance && defendantClearsSwapList) {
                        proposedDefenseSwapTeams.add(defendants.get(b));
                    }
                }
                if (proposedPlaintiffSwapTeams.size() > 1) {
                    BigDecimal[] record = new BigDecimal[3];
                    for (int b = 0; b < 2; b++) {
                        record[b + 1] = new BigDecimal(proposedPlaintiffSwapTeams.get(0).getWins() + proposedPlaintiffSwapTeams.get(0).getTies() * .5);
                        if (proposedPlaintiffSwapTeams.get(b).isByeTeam()) {
                            record[b + 1] = new BigDecimal(-1);
                        }
                    }
                    record[0] = new BigDecimal(plaintiffs.get(a).getWins() + plaintiffs.get(a).getTies() * .5);
                    if (plaintiffs.get(a).isByeTeam()) {
                        record[0] = new BigDecimal(-1);
                    }
                    if (record[0].subtract(record[1]).abs().compareTo(record[0].subtract(record[2]).abs()) > 0) {
                        proposedPlaintiffSwapTeams.remove(1);
                    } else if (record[0].subtract(record[1]).abs().compareTo(record[0].subtract(record[2]).abs()) < 0) {
                        proposedPlaintiffSwapTeams.remove(0);
                    } else if (getTeamCS(plaintiffs.get(a).getTeamNumber()).subtract(getTeamCS(proposedPlaintiffSwapTeams.get(0).getTeamNumber())).abs().compareTo(getTeamCS(plaintiffs.get(a).getTeamNumber()).subtract(getTeamCS(proposedPlaintiffSwapTeams.get(1).getTeamNumber())).abs()) < 0) {
                        proposedPlaintiffSwapTeams.remove(1);
                    } else if (getTeamCS(plaintiffs.get(a).getTeamNumber()).subtract(getTeamCS(proposedPlaintiffSwapTeams.get(0).getTeamNumber())).abs().compareTo(getTeamCS(plaintiffs.get(a).getTeamNumber()).subtract(getTeamCS(proposedPlaintiffSwapTeams.get(1).getTeamNumber())).abs()) > 0) {
                        proposedPlaintiffSwapTeams.remove(0);
                    } else if (Math.abs(proposedPlaintiffSwapTeams.get(0).getPD() - plaintiffs.get(a).getPD()) < Math.abs(proposedPlaintiffSwapTeams.get(1).getPD() - plaintiffs.get(a).getPD())) {
                        proposedPlaintiffSwapTeams.remove(1);
                    } else if (Math.abs(proposedPlaintiffSwapTeams.get(0).getPD() - plaintiffs.get(a).getPD()) > Math.abs(proposedPlaintiffSwapTeams.get(1).getPD() - plaintiffs.get(a).getPD())) {
                        proposedPlaintiffSwapTeams.remove(0);
                    } else //TODO: account for random of team number high or low
                    {
                        if (proposedPlaintiffSwapTeams.get(0).getTeamNumber() > proposedPlaintiffSwapTeams.get(1).getTeamNumber()) {
                            proposedPlaintiffSwapTeams.remove(0);
                        } else {
                            proposedPlaintiffSwapTeams.remove(1);
                        }
                    }
                }
                final Team pSwap = proposedPlaintiffSwapTeams.get(0);
                if (proposedDefenseSwapTeams.size() > 1) {
                    BigDecimal[] record = new BigDecimal[3];
                    for (int b = 0; b < 2; b++) {
                        record[b + 1] = new BigDecimal(proposedDefenseSwapTeams.get(0).getWins() + proposedDefenseSwapTeams.get(0).getTies() * .5);
                        if (proposedDefenseSwapTeams.get(b).isByeTeam()) {
                            record[b + 1] = new BigDecimal(-1);
                        }
                    }
                    record[0] = new BigDecimal(defendants.get(a).getWins() + defendants.get(a).getTies() * .5);
                    if (defendants.get(a).isByeTeam()) {
                        record[0] = new BigDecimal(-1);
                    }
                    if (record[0].subtract(record[1]).abs().compareTo(record[0].subtract(record[2]).abs()) > 0) {
                        proposedDefenseSwapTeams.remove(1);
                    } else if (record[0].subtract(record[1]).abs().compareTo(record[0].subtract(record[2]).abs()) < 0) {
                        proposedDefenseSwapTeams.remove(0);
                    } else if (getTeamCS(defendants.get(a).getTeamNumber()).subtract(getTeamCS(proposedDefenseSwapTeams.get(0).getTeamNumber())).abs().compareTo(getTeamCS(defendants.get(a).getTeamNumber()).subtract(getTeamCS(proposedDefenseSwapTeams.get(1).getTeamNumber())).abs()) < 0) {
                        proposedDefenseSwapTeams.remove(1);
                    } else if (getTeamCS(defendants.get(a).getTeamNumber()).subtract(getTeamCS(proposedDefenseSwapTeams.get(0).getTeamNumber())).abs().compareTo(getTeamCS(defendants.get(a).getTeamNumber()).subtract(getTeamCS(proposedDefenseSwapTeams.get(1).getTeamNumber())).abs()) > 0) {
                        proposedDefenseSwapTeams.remove(0);
                    } else if (Math.abs(proposedDefenseSwapTeams.get(0).getPD() - defendants.get(a).getPD()) < Math.abs(proposedDefenseSwapTeams.get(1).getPD() - defendants.get(a).getPD())) {
                        proposedDefenseSwapTeams.remove(1);
                    } else if (Math.abs(proposedDefenseSwapTeams.get(0).getPD() - defendants.get(a).getPD()) > Math.abs(proposedDefenseSwapTeams.get(1).getPD() - defendants.get(a).getPD())) {
                        proposedDefenseSwapTeams.remove(0);
                    } else //TODO: account for random of team number high or low
                    {
                        if (proposedDefenseSwapTeams.get(0).getTeamNumber() > proposedDefenseSwapTeams.get(1).getTeamNumber()) {
                            proposedDefenseSwapTeams.remove(0);
                        } else {
                            proposedDefenseSwapTeams.remove(1);
                        }
                    }
                }
                final Team dSwap = proposedDefenseSwapTeams.get(0);
                if (plaintiffRankDistance < defenseRankDistance) {
                    //swap on P
                    Integer[] swap = {Math.min(plaintiffs.get(a).getTeamNumber(), pSwap.getTeamNumber()), Math.max(plaintiffs.get(a).getTeamNumber(), pSwap.getTeamNumber())};
                    plaintiffs.set(plaintiffs.indexOf(pSwap), plaintiffs.get(a));
                    plaintiffs.set(a, pSwap);
                    swapList.add(swap);
                } else if (plaintiffRankDistance > defenseRankDistance) {
                    //swap on D
                    Integer[] swap = {Math.min(defendants.get(a).getTeamNumber(), dSwap.getTeamNumber()), Math.max(defendants.get(a).getTeamNumber(), dSwap.getTeamNumber())};
                    defendants.set(defendants.indexOf(dSwap), defendants.get(a));
                    defendants.set(a, dSwap);
                    swapList.add(swap);
                } else if (Math.abs((pSwap.getWins() + .5 * pSwap.getTies()) - (plaintiffs.get(a).getWins() + plaintiffs.get(a).getTies() * .5))
                        < Math.abs((dSwap.getWins() + .5 * dSwap.getTies() - (defendants.get(a).getWins() + defendants.get(a).getTies())))) {
                    //Swap on P
                    Integer[] swap = {Math.min(plaintiffs.get(a).getTeamNumber(), pSwap.getTeamNumber()), Math.max(plaintiffs.get(a).getTeamNumber(), pSwap.getTeamNumber())};
                    plaintiffs.set(plaintiffs.indexOf(pSwap), plaintiffs.get(a));
                    plaintiffs.set(a, pSwap);
                    swapList.add(swap);
                } else if (Math.abs((pSwap.getWins() + .5 * pSwap.getTies()) - (plaintiffs.get(a).getWins() + plaintiffs.get(a).getTies() * .5))
                        > Math.abs((dSwap.getWins() + .5 * dSwap.getTies() - (defendants.get(a).getWins() + defendants.get(a).getTies())))) {
                    //Swap on D
                    Integer[] swap = {Math.min(defendants.get(a).getTeamNumber(), dSwap.getTeamNumber()), Math.max(defendants.get(a).getTeamNumber(), dSwap.getTeamNumber())};
                    defendants.set(defendants.indexOf(dSwap), defendants.get(a));
                    defendants.set(a, dSwap);
                    swapList.add(swap);
                } else if (getTeamCS(plaintiffs.get(a).getTeamNumber()).subtract(getTeamCS(pSwap.getTeamNumber())).abs().compareTo(getTeamCS(defendants.get(a).getTeamNumber()).subtract(getTeamCS(dSwap.getTeamNumber())).abs()) < 0) {
                    //Swap on P
                    Integer[] swap = {Math.min(plaintiffs.get(a).getTeamNumber(), pSwap.getTeamNumber()), Math.max(plaintiffs.get(a).getTeamNumber(), pSwap.getTeamNumber())};
                    plaintiffs.set(plaintiffs.indexOf(pSwap), plaintiffs.get(a));
                    plaintiffs.set(a, pSwap);
                    swapList.add(swap);
                } else if (getTeamCS(plaintiffs.get(a).getTeamNumber()).subtract(getTeamCS(pSwap.getTeamNumber())).abs().compareTo(getTeamCS(defendants.get(a).getTeamNumber()).subtract(getTeamCS(dSwap.getTeamNumber())).abs()) > 0) {
                    //Swap on D
                    Integer[] swap = {Math.min(defendants.get(a).getTeamNumber(), dSwap.getTeamNumber()), Math.max(defendants.get(a).getTeamNumber(), dSwap.getTeamNumber())};
                    defendants.set(defendants.indexOf(dSwap), defendants.get(a));
                    defendants.set(a, dSwap);
                    swapList.add(swap);
                } else if (Math.abs(plaintiffs.get(a).getPD() - pSwap.getPD()) < Math.abs(defendants.get(a).getPD() - dSwap.getPD())) {
                    //Swap on P
                    Integer[] swap = {Math.min(plaintiffs.get(a).getTeamNumber(), pSwap.getTeamNumber()), Math.max(plaintiffs.get(a).getTeamNumber(), pSwap.getTeamNumber())};
                    plaintiffs.set(plaintiffs.indexOf(pSwap), plaintiffs.get(a));
                    plaintiffs.set(a, pSwap);
                    swapList.add(swap);
                } else if (Math.abs(plaintiffs.get(a).getPD() - pSwap.getPD()) > Math.abs(defendants.get(a).getPD() - dSwap.getPD())) {
                    //Swap on D
                    Integer[] swap = {Math.min(defendants.get(a).getTeamNumber(), dSwap.getTeamNumber()), Math.max(defendants.get(a).getTeamNumber(), dSwap.getTeamNumber())};
                    defendants.set(defendants.indexOf(dSwap), defendants.get(a));
                    defendants.set(a, dSwap);
                    swapList.add(swap);
                } else if (plaintiffs.indexOf(pSwap) > defendants.indexOf(dSwap)) {
                    //Swap on D
                    Integer[] swap = {Math.min(defendants.get(a).getTeamNumber(), dSwap.getTeamNumber()), Math.max(defendants.get(a).getTeamNumber(), dSwap.getTeamNumber())};
                    defendants.set(defendants.indexOf(dSwap), defendants.get(a));
                    defendants.set(a, dSwap);
                    swapList.add(swap);
                } else if (plaintiffs.indexOf(proposedPlaintiffSwapTeams.get(0)) < defendants.indexOf(proposedDefenseSwapTeams.get(0))) {
                    //Swap on P
                    Integer[] swap = {Math.min(plaintiffs.get(a).getTeamNumber(), pSwap.getTeamNumber()), Math.max(plaintiffs.get(a).getTeamNumber(), pSwap.getTeamNumber())};
                    plaintiffs.set(plaintiffs.indexOf(pSwap), plaintiffs.get(a));
                    plaintiffs.set(a, pSwap);
                    swapList.add(swap);
                } else {
                    //Swap on D (See Tab Manual at 35)
                    Integer[] swap = {Math.min(defendants.get(a).getTeamNumber(), dSwap.getTeamNumber()), Math.max(defendants.get(a).getTeamNumber(), dSwap.getTeamNumber())};
                    defendants.set(defendants.indexOf(dSwap), defendants.get(a));
                    defendants.set(a, dSwap);
                    swapList.add(swap);
                }
                a = -1;
            }
        }
        ArrayList<Team>[] pairings = new ArrayList[2];
        pairings[0] = plaintiffs;
        pairings[1] = defendants;
        return pairings;
    }

    private ArrayList<Team> resolveImpermissibleMatches(ArrayList<Team> pairings) {
        final ArrayList<Integer[]> swapList = new ArrayList<>();
        for (int a = 0; a * 2 < pairings.size(); a++) {
            if (pairings.get(a * 2).getImpermissibleMatches().contains(pairings.get(a * 2 + 1).getTeamNumber())) {
                int plaintiffRankDistance = Integer.MAX_VALUE;
                int closestToPlaintiff = 0;
                int defenseRankDistance = Integer.MAX_VALUE;
                int closestToDefense = 0;
                for (int b = 0; b < pairings.size(); b++) {
                    Integer[] proposedPlaintiffSwap = {Math.min(pairings.get(a * 2).getTeamNumber(), pairings.get(b).getTeamNumber()), Math.max(pairings.get(a * 2).getTeamNumber(), pairings.get(b).getTeamNumber())};
                    boolean plaintiffClearsSwapList = true;
                    for (int c = 0; c < swapList.size(); c++) {
                        if (swapList.get(c)[0].equals(proposedPlaintiffSwap[0]) && swapList.get(c)[1].equals(proposedPlaintiffSwap[1])) {
                            plaintiffClearsSwapList = false;
                        }
                    }
                    if (Math.abs(a * 2 - b) < plaintiffRankDistance && b != a * 2 && b != a * 2 + 1 && plaintiffClearsSwapList) {
                        closestToPlaintiff = b;
                    }
                    Integer[] proposedDefenseSwap = {Math.min(pairings.get(a * 2 + 1).getTeamNumber(), pairings.get(b).getTeamNumber()), Math.max(pairings.get(a * 2 + 1).getTeamNumber(), pairings.get(b).getTeamNumber())};
                    boolean defendantClearsSwapList = true;
                    for (int c = 0; c < swapList.size(); c++) {
                        if (swapList.get(c)[0].equals(proposedDefenseSwap[0]) && swapList.get(c)[1].equals(proposedDefenseSwap[1])) {
                            defendantClearsSwapList = false;
                        }
                    }
                    if (Math.abs(a * 2 - b + 1) < defenseRankDistance && b != a * 2 && b != a * 2 + 1 && defendantClearsSwapList) {
                        closestToDefense = b;
                    }
                }
                if (Math.abs(pairings.get(a * 2).getWins() + pairings.get(a * 2).getTies() * .5 - pairings.get(closestToPlaintiff).getWins() - pairings.get(closestToPlaintiff).getTies() * .5)
                        < Math.abs(pairings.get(a * 2 + 1).getWins() + pairings.get(a * 2 + 1).getTies() * .5 - pairings.get(closestToDefense).getWins() - +pairings.get(a * 2 + 1).getTies() * .5)) {
                    Team plaintiff = pairings.get(a * 2);
                    pairings.set(a * 2, pairings.get(closestToPlaintiff));
                    pairings.set(closestToPlaintiff, plaintiff);
                    Integer[] plaintiffSwap = {Math.min(pairings.get(a * 2).getTeamNumber(), pairings.get(closestToPlaintiff).getTeamNumber()), Math.max(pairings.get(a * 2).getTeamNumber(), pairings.get(closestToPlaintiff).getTeamNumber())};
                    swapList.add(plaintiffSwap);
                    a = -1;
                } else if (Math.abs(pairings.get(a * 2).getWins() + pairings.get(a * 2).getTies() * .5 - pairings.get(closestToPlaintiff).getWins() - pairings.get(closestToPlaintiff).getTies() * .5)
                        > Math.abs(pairings.get(a * 2 + 1).getWins() + pairings.get(a * 2 + 1).getTies() * .5 - pairings.get(closestToDefense).getWins() - +pairings.get(a * 2 + 1).getTies() * .5)) {
                    Team defendant = pairings.get(a * 2 + 1);
                    pairings.set(a * 2 + 1, pairings.get(closestToDefense));
                    pairings.set(closestToDefense, defendant);
                    Integer[] defenseSwap = {Math.min(pairings.get(a * 2 + 1).getTeamNumber(), pairings.get(closestToDefense).getTeamNumber()), Math.max(pairings.get(a * 2 + 1).getTeamNumber(), pairings.get(closestToDefense).getTeamNumber())};
                    swapList.add(defenseSwap);
                    a = -1;
                } else //evaluate by CS
                {
                    if (getTeamCS(pairings.get(a * 2).getTeamNumber()).subtract(getTeamCS(pairings.get(closestToPlaintiff).getTeamNumber())).abs().compareTo(
                            getTeamCS(pairings.get(a * 2 + 1).getTeamNumber()).subtract(getTeamCS(pairings.get(closestToDefense).getTeamNumber())).abs()) < 0) {
                        Team plaintiff = pairings.get(a * 2);
                        pairings.set(a * 2, pairings.get(closestToPlaintiff));
                        pairings.set(closestToPlaintiff, plaintiff);
                        Integer[] plaintiffSwap = {Math.min(pairings.get(a * 2).getTeamNumber(), pairings.get(closestToPlaintiff).getTeamNumber()), Math.max(pairings.get(a * 2).getTeamNumber(), pairings.get(closestToPlaintiff).getTeamNumber())};
                        swapList.add(plaintiffSwap);
                        a = -1;
                    } else if (getTeamCS(pairings.get(a * 2).getTeamNumber()).subtract(getTeamCS(pairings.get(closestToPlaintiff).getTeamNumber())).abs().compareTo(
                            getTeamCS(pairings.get(a * 2 + 1).getTeamNumber()).subtract(getTeamCS(pairings.get(closestToDefense).getTeamNumber())).abs()) > 0) {
                        Team defendant = pairings.get(a * 2 + 1);
                        pairings.set(a * 2 + 1, pairings.get(closestToDefense));
                        pairings.set(closestToDefense, defendant);
                        Integer[] defenseSwap = {Math.min(pairings.get(a * 2 + 1).getTeamNumber(), pairings.get(closestToDefense).getTeamNumber()), Math.max(pairings.get(a * 2 + 1).getTeamNumber(), pairings.get(closestToDefense).getTeamNumber())};
                        swapList.add(defenseSwap);
                        a = -1;
                    } else //Evaluate by PD
                    {
                        if (Math.abs(pairings.get(a * 2).getPD() - pairings.get(closestToPlaintiff).getPD())
                                < Math.abs(pairings.get(a * 2 + 1).getPD() - pairings.get(closestToDefense).getPD())) {
                            Team plaintiff = pairings.get(a * 2);
                            pairings.set(a * 2, pairings.get(closestToPlaintiff));
                            pairings.set(closestToPlaintiff, plaintiff);
                            Integer[] plaintiffSwap = {Math.min(pairings.get(a * 2).getTeamNumber(), pairings.get(closestToPlaintiff).getTeamNumber()), Math.max(pairings.get(a * 2).getTeamNumber(), pairings.get(closestToPlaintiff).getTeamNumber())};
                            swapList.add(plaintiffSwap);
                            a = -1;
                        } else if (Math.abs(pairings.get(a * 2).getPD() - pairings.get(closestToPlaintiff).getPD())
                                > Math.abs(pairings.get(a * 2 + 1).getPD() - pairings.get(closestToDefense).getPD())) {
                            Team defendant = pairings.get(a * 2 + 1);
                            pairings.set(a * 2 + 1, pairings.get(closestToDefense));
                            pairings.set(closestToDefense, defendant);
                            Integer[] defenseSwap = {Math.min(pairings.get(a * 2 + 1).getTeamNumber(), pairings.get(closestToDefense).getTeamNumber()), Math.max(pairings.get(a * 2 + 1).getTeamNumber(), pairings.get(closestToDefense).getTeamNumber())};
                            swapList.add(defenseSwap);
                            a = -1;
                        } else //evaluate by sum of ranks
                        {
                            if (a * 2 + closestToPlaintiff > a * 2 + 1 + closestToDefense) {
                                Team plaintiff = pairings.get(a * 2);
                                pairings.set(a * 2, pairings.get(closestToPlaintiff));
                                pairings.set(closestToPlaintiff, plaintiff);
                                Integer[] plaintiffSwap = {Math.min(pairings.get(a * 2).getTeamNumber(), pairings.get(closestToPlaintiff).getTeamNumber()), Math.max(pairings.get(a * 2).getTeamNumber(), pairings.get(closestToPlaintiff).getTeamNumber())};
                                swapList.add(plaintiffSwap);
                            } else {
                                Team defendant = pairings.get(a * 2 + 1);
                                pairings.set(a * 2 + 1, pairings.get(closestToDefense));
                                pairings.set(closestToDefense, defendant);
                                Integer[] defenseSwap = {Math.min(pairings.get(a * 2 + 1).getTeamNumber(), pairings.get(closestToDefense).getTeamNumber()), Math.max(pairings.get(a * 2 + 1).getTeamNumber(), pairings.get(closestToDefense).getTeamNumber())};
                                swapList.add(defenseSwap);
                                a = -1;
                            }
                        }
                    }
                }
            }
        }
        return pairings;
    }

    public void writePairingsToTournament(int[][] pairings, int roundNumber) {
        for (int a = 0; a < pairings.length; a++) {
            switch (roundNumber) {
                case 1:
                    teams.get(pairings[a][0]).setRound1Plaintiff(true);
                    teams.get(pairings[a][1]).setRound1Plaintiff(false);
                    teams.get(pairings[a][0]).setRound1Opponent(teams.get(pairings[a][1]).getTeamNumber());
                    teams.get(pairings[a][1]).setRound1Opponent(teams.get(pairings[a][0]).getTeamNumber());
                    teams.get(pairings[a][0]).addImpermissibleMatch(teams.get(pairings[a][1]).getTeamNumber());
                    teams.get(pairings[a][1]).addImpermissibleMatch(teams.get(pairings[a][0]).getTeamNumber());
                    break;
                case 2:
                    teams.get(pairings[a][0]).setRound2Opponent(teams.get(pairings[a][1]).getTeamNumber());
                    teams.get(pairings[a][1]).setRound2Opponent(teams.get(pairings[a][0]).getTeamNumber());
                    teams.get(pairings[a][0]).addImpermissibleMatch(teams.get(pairings[a][1]).getTeamNumber());
                    teams.get(pairings[a][1]).addImpermissibleMatch(teams.get(pairings[a][0]).getTeamNumber());
                    break;
                case 3:
                    teams.get(pairings[a][0]).setRound3Plaintiff(true);
                    teams.get(pairings[a][1]).setRound3Plaintiff(false);
                    teams.get(pairings[a][0]).setRound3Opponent(teams.get(pairings[a][1]).getTeamNumber());
                    teams.get(pairings[a][1]).setRound3Opponent(teams.get(pairings[a][0]).getTeamNumber());
                    teams.get(pairings[a][0]).addImpermissibleMatch(teams.get(pairings[a][1]).getTeamNumber());
                    teams.get(pairings[a][1]).addImpermissibleMatch(teams.get(pairings[a][0]).getTeamNumber());
                    break;
                case 4:
                    teams.get(pairings[a][0]).setRound4Opponent(teams.get(pairings[a][1]).getTeamNumber());
                    teams.get(pairings[a][1]).setRound4Opponent(teams.get(pairings[a][0]).getTeamNumber());
                    teams.get(pairings[a][0]).addImpermissibleMatch(teams.get(pairings[a][1]).getTeamNumber());
                    teams.get(pairings[a][1]).addImpermissibleMatch(teams.get(pairings[a][0]).getTeamNumber());
                    break;
            }
        }
    }

    /**
     * Returns the CS of the specified team
     *
     * @param teamNumber team whose CS is to be returned
     * @return CS of the team in question
     */
    public BigDecimal getTeamCS(int teamNumber) {
        BigDecimal cs = new BigDecimal("0.0");
        for (int a = 0; a < teams.size(); a++) {
            if (teams.get(a).getRound1Opponent() == teamNumber) {
                cs = cs.add(teams.get(a).getStatisticalWins());
            }
            if (teams.get(a).getRound2Opponent() == teamNumber) {
                cs = cs.add(teams.get(a).getStatisticalWins());
            }
            if (teams.get(a).getRound3Opponent() == teamNumber) {
                cs = cs.add(teams.get(a).getStatisticalWins());
            }
            if (teams.get(a).getRound4Opponent() == teamNumber) {
                cs = cs.add(teams.get(a).getStatisticalWins());
            }
        }
        return cs;
    }

    public BigDecimal getTeamOCS(int teamNumber){
        BigDecimal ocs = new BigDecimal("0.0");
        Team team = teams.get(getTeamIndex(teamNumber));
        ocs = ocs.add(getTeamCS(team.getRound1Opponent()));
        ocs = ocs.add(getTeamCS(team.getRound2Opponent()));
        ocs = ocs.add(getTeamCS(team.getRound3Opponent()));
        ocs = ocs.add(getTeamCS(team.getRound4Opponent()));
        return ocs;
    }
    
    public ArrayList<Team> sortTeams(ArrayList<Team> teams) {
        ArrayList<Team> teamsToSort = (ArrayList<Team>) teams.clone();
        ArrayList<Team> sortedTeams = new ArrayList<>();
        while (!teamsToSort.isEmpty()) {
            ArrayList<Team> sameRecordArray = new ArrayList<>();
            ArrayList<Team> sameCSArray = new ArrayList<>();
            ArrayList<Team> samePDArray = new ArrayList<>();
            if (teamsToSort.size() == 1 && teamsToSort.get(0).isByeTeam()) {
                sortedTeams.add(teamsToSort.get(0));
                teamsToSort.remove(0);
            }
            BigDecimal maxRecord = new BigDecimal("0.0");
            for (int a = 0; a < teamsToSort.size(); a++) {
                if (maxRecord.compareTo(teamsToSort.get(a).getStatisticalWins()) < 0 && !teamsToSort.get(a).isByeTeam()) {
                    maxRecord = teamsToSort.get(a).getStatisticalWins();
                }
            }
            for (int a = 0; a < teamsToSort.size(); a++) {
                if (teamsToSort.get(a).getStatisticalWins().compareTo(maxRecord) == 0 && !teamsToSort.get(a).isByeTeam()) {
                    sameRecordArray.add(teamsToSort.get(a));
                }
            }

            BigDecimal maxCS = new BigDecimal("0.0");
            for (int a = 0; a < sameRecordArray.size(); a++) {
                if (getTeamCS(sameRecordArray.get(a).getTeamNumber()).compareTo(maxCS) > 0) {
                    maxCS = getTeamCS(sameRecordArray.get(a).getTeamNumber());
                }
            }
            for (int a = 0; a < sameRecordArray.size(); a++) {
                if (getTeamCS(sameRecordArray.get(a).getTeamNumber()).compareTo(maxCS) == 0) {
                    sameCSArray.add(sameRecordArray.get(a));
                    sameRecordArray.remove(a);
                    a = -1;
                }

            }

            int maxPD = -9999;
            for (int a = 0; a < sameCSArray.size(); a++) {
                if (sameCSArray.get(a).getPD() > maxPD) {
                    maxPD = sameCSArray.get(a).getPD();
                }
            }
            for (int a = 0; a < sameCSArray.size(); a++) {
                if (sameCSArray.get(a).getPD() == maxPD) {
                    samePDArray.add(sameCSArray.get(a));
                    sameCSArray.remove(a);
                    a = -1;
                }

            }
            while (!samePDArray.isEmpty()) {
                int teamNumberExtreme;
                if (lowerTeamNumberIsHigherRank) {
                    teamNumberExtreme = 10000;
                    for (int a = 0; a < samePDArray.size(); a++) {
                        if (samePDArray.get(a).getTeamNumber() < teamNumberExtreme) {
                            teamNumberExtreme = samePDArray.get(a).getTeamNumber();
                        }
                    }
                    for (int a = 0; a < samePDArray.size(); a++) {
                        if (samePDArray.get(a).getTeamNumber() == teamNumberExtreme) {
                            sortedTeams.add(samePDArray.get(a));
                            teamsToSort.remove(samePDArray.get(a));
                            samePDArray.remove(a);

                        }
                    }
                } else {
                    teamNumberExtreme = 0;
                    for (int a = 0; a < samePDArray.size(); a++) {
                        if (samePDArray.get(a).getTeamNumber() > teamNumberExtreme) {
                            teamNumberExtreme = samePDArray.get(a).getTeamNumber();
                        }
                    }
                    for (int a = 0; a < samePDArray.size(); a++) {
                        if (samePDArray.get(a).getTeamNumber() == teamNumberExtreme) {
                            sortedTeams.add(samePDArray.get(a));
                            teamsToSort.remove(samePDArray.get(a));
                            samePDArray.remove(a);
                        }
                    }
                }
            }
        }
        return sortedTeams;
    }
    
    public ArrayList<Team> placeTeams(ArrayList<Team> teams){
        ArrayList<Team> teamsToSort = (ArrayList<Team>) teams.clone();
        ArrayList<Team> sortedTeams = new ArrayList<>();
        while (!teamsToSort.isEmpty()) {
            ArrayList<Team> sameRecordArray = new ArrayList<>();
            ArrayList<Team> sameCSArray = new ArrayList<>();
            ArrayList<Team> sameOCSArray = new ArrayList<>();
            ArrayList<Team> samePDArray = new ArrayList<>();
            if (teamsToSort.size() == 1 && teamsToSort.get(0).isByeTeam()) {
                sortedTeams.add(teamsToSort.get(0));
                teamsToSort.remove(0);
            }
            BigDecimal maxRecord = new BigDecimal("0.0");
            for (int a = 0; a < teamsToSort.size(); a++) {
                if (maxRecord.compareTo(teamsToSort.get(a).getStatisticalWins()) < 0 && !teamsToSort.get(a).isByeTeam()) {
                    maxRecord = teamsToSort.get(a).getStatisticalWins();
                }
            }
            for (int a = 0; a < teamsToSort.size(); a++) {
                if (teamsToSort.get(a).getStatisticalWins().compareTo(maxRecord) == 0 && !teamsToSort.get(a).isByeTeam()) {
                    sameRecordArray.add(teamsToSort.get(a));
                }
            }

            BigDecimal maxCS = new BigDecimal("0.0");
            for (int a = 0; a < sameRecordArray.size(); a++) {
                if (getTeamCS(sameRecordArray.get(a).getTeamNumber()).compareTo(maxCS) > 0) {
                    maxCS = getTeamCS(sameRecordArray.get(a).getTeamNumber());
                }
            }
            for (int a = 0; a < sameRecordArray.size(); a++) {
                if (getTeamCS(sameRecordArray.get(a).getTeamNumber()).compareTo(maxCS) == 0) {
                    sameCSArray.add(sameRecordArray.get(a));
                    sameRecordArray.remove(a);
                    a = -1;
                }

            }

            int maxPD = -9999;
            for (int a = 0; a < sameCSArray.size(); a++) {
                if (sameCSArray.get(a).getPD() > maxPD) {
                    maxPD = sameCSArray.get(a).getPD();
                }
            }
            for (int a = 0; a < sameCSArray.size(); a++) {
                if (sameCSArray.get(a).getPD() == maxPD) {
                    samePDArray.add(sameCSArray.get(a));
                    sameCSArray.remove(a);
                    a = -1;
                }

            }
            while (!samePDArray.isEmpty()) {
                int teamNumberExtreme;
                if (lowerTeamNumberIsHigherRank) {
                    teamNumberExtreme = 10000;
                    for (int a = 0; a < samePDArray.size(); a++) {
                        if (samePDArray.get(a).getTeamNumber() < teamNumberExtreme) {
                            teamNumberExtreme = samePDArray.get(a).getTeamNumber();
                        }
                    }
                    for (int a = 0; a < samePDArray.size(); a++) {
                        if (samePDArray.get(a).getTeamNumber() == teamNumberExtreme) {
                            sortedTeams.add(samePDArray.get(a));
                            teamsToSort.remove(samePDArray.get(a));
                            samePDArray.remove(a);

                        }
                    }
                } else {
                    teamNumberExtreme = 0;
                    for (int a = 0; a < samePDArray.size(); a++) {
                        if (samePDArray.get(a).getTeamNumber() > teamNumberExtreme) {
                            teamNumberExtreme = samePDArray.get(a).getTeamNumber();
                        }
                    }
                    for (int a = 0; a < samePDArray.size(); a++) {
                        if (samePDArray.get(a).getTeamNumber() == teamNumberExtreme) {
                            sortedTeams.add(samePDArray.get(a));
                            teamsToSort.remove(samePDArray.get(a));
                            samePDArray.remove(a);
                        }
                    }
                }
            }
        }
        for(int i = 0;i<sortedTeams.size();i++){
            final Team t = sortedTeams.get(i);
            System.out.println(t.getTeamNumber()+" "+t.getStatisticalWins()+" "+getTeamCS(t.getTeamNumber())+" "+t.getPD());
        }
        return sortedTeams;
    }

    public boolean isLowerTeamNumberIsHigherRank() {
        return lowerTeamNumberIsHigherRank;
    }

    public boolean isRound3Rank1IsPlaintiff() {
        return round3Rank1IsPlaintiff;
    }

    public int getTeamIndex(int teamNumber) {
        int index = 0;
        for (int a = 0; a < teams.size(); a++) {
            if (teams.get(a).getTeamNumber() == teamNumber) {
                index = a;
                a = teams.size();
            }
        }
        return index;
    }

}
